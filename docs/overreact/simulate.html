<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.2.0" />
    <title>overreact.simulate API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>

<script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
    /* Re-invoke MathJax when DOM content changes, for example during search. */
    document.addEventListener("DOMContentLoaded", () => {
        new MutationObserver(() => MathJax.typeset()).observe(
            document.querySelector("main.pdoc").parentNode,
            {childList: true}
        );
    })
</script>
<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../overreact.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;overreact</a>

<a href="/overreact">                        <img src="https://raw.githubusercontent.com/geem-lab/overreact-guide/master/logo.png" class="logo" alt="project logo"/>
</a>
                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="function" href="#get_y">get_y</a>
            </li>
            <li>
                    <a class="function" href="#get_dydt">get_dydt</a>
            </li>
            <li>
                    <a class="function" href="#get_fixed_scheme">get_fixed_scheme</a>
            </li>
    </ul>


                    <footer>overreact</footer>

                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                        <a class="pdoc-button git-button" href="https://github.com/geem-lab/overreact/blob/main/overreact/simulate.py">Edit on GitHub</a>
                    <h1 class="modulename">
<a href="./../overreact.html">overreact</a><wbr>.simulate    </h1>

                        <div class="docstring"><p>Module dedicated to the time simulation of reaction models.</p>

<p>Here are functions that calculate reaction rates as well, which is needed for
the time simulations.</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="sd">&quot;&quot;&quot;Module dedicated to the time simulation of reaction models.</span>

<span class="sd">Here are functions that calculate reaction rates as well, which is needed for</span>
<span class="sd">the time simulations.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># TODO: type this module.</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;get_y&quot;</span><span class="p">,</span> <span class="s2">&quot;get_dydt&quot;</span><span class="p">,</span> <span class="s2">&quot;get_fixed_scheme&quot;</span><span class="p">]</span>


<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize_scalar</span>

<span class="kn">import</span> <span class="nn">overreact</span> <span class="k">as</span> <span class="nn">rx</span>
<span class="kn">from</span> <span class="nn">overreact</span> <span class="kn">import</span> <span class="n">_constants</span> <span class="k">as</span> <span class="n">constants</span>
<span class="kn">from</span> <span class="nn">overreact._misc</span> <span class="kn">import</span> <span class="n">_found_jax</span>

<span class="n">EF</span> <span class="o">=</span> <span class="mi">5</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">if</span> <span class="n">_found_jax</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">jax.numpy</span> <span class="k">as</span> <span class="nn">jnp</span>
    <span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">jacfwd</span><span class="p">,</span> <span class="n">jit</span>
    <span class="kn">from</span> <span class="nn">jax.config</span> <span class="kn">import</span> <span class="n">config</span>

    <span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;jax_enable_x64&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
        <span class="s2">&quot;Install JAX to have just-in-time compilation: &quot;</span>
        <span class="s1">&#39;pip install jax (or pip install &quot;overreact[fast]&quot;)&#39;</span>
    <span class="p">)</span>
    <span class="n">jnp</span> <span class="o">=</span> <span class="n">np</span>


<span class="c1"># TODO(schneiderfelipe): allow y0 to be a dict-like object.</span>
<span class="k">def</span> <span class="nf">get_y</span><span class="p">(</span>
    <span class="n">dydt</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t_span</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Radau&quot;</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-11</span><span class="p">,</span> <span class="n">max_time</span><span class="o">=</span><span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulate a reaction scheme from its rate function.</span>

<span class="sd">    This function provides two functions that calculate the concentrations and</span>
<span class="sd">    the rates of formation at any point in time for any compound. It does that</span>
<span class="sd">    by solving an initial value problem (IVP) through scipy&#39;s ``solve_ivp``</span>
<span class="sd">    under the hood.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dydt : callable</span>
<span class="sd">        Right-hand side of the system.</span>
<span class="sd">    y0 : array-like</span>
<span class="sd">        Initial state.</span>
<span class="sd">    t_span : array-like, optional</span>
<span class="sd">        Interval of integration (t0, tf). The solver starts with t=t0 and</span>
<span class="sd">        integrates until it reaches t=tf. If not given, a conservative value</span>
<span class="sd">        is chosen based on the system at hand (the method of choice works for</span>
<span class="sd">        any zeroth-, first- or second-order reactions).</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Integration method to use. See `scipy.integrate.solve_ivp` for details.</span>
<span class="sd">        Kinetics problems are very often stiff and, as such, &quot;RK45&quot; is</span>
<span class="sd">        normally unsuited. &quot;Radau&quot;, &quot;BDF&quot; or &quot;LSODA&quot; are good choices.</span>
<span class="sd">    rtol, atol : array-like</span>
<span class="sd">        See `scipy.integrate.solve_ivp` for details.</span>
<span class="sd">    max_time : float, optional</span>
<span class="sd">        If `t_span` is not given, an interval will be estimated, but it can&#39;t</span>
<span class="sd">        be larger than this parameter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y, r : callable</span>
<span class="sd">        Concentrations and reaction rates as functions of time. The y object</span>
<span class="sd">        is an OdeSolution and stores attributes t_min and t_max.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import overreact as rx</span>

<span class="sd">    A toy simulation can be performed in just two lines:</span>

<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;A &lt;=&gt; B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y, r = get_y(get_dydt(scheme, np.array([1, 1])), y0=[1, 0])</span>

<span class="sd">    The `y` object stores information about the simulation time, which can be</span>
<span class="sd">    used to produce a suitable vector of timepoints for, e.g., plotting:</span>

<span class="sd">    &gt;&gt;&gt; y.t_min, y.t_max  # doctest: +SKIP</span>
<span class="sd">    (0.0, 3.0)</span>
<span class="sd">    &gt;&gt;&gt; t = np.linspace(y.t_min, y.t_max)</span>
<span class="sd">    &gt;&gt;&gt; t  # doctest: +SKIP</span>
<span class="sd">    array([0. , 0.06122449, ..., 2.93877551, 3. ])</span>

<span class="sd">    Both `y` and `r` can be used to check concentrations and rates in any</span>
<span class="sd">    point in time. In particular, both are vectorized:</span>

<span class="sd">    &gt;&gt;&gt; y(t)  # doctest: +SKIP</span>
<span class="sd">    array([[1. , 0.94237559, ..., 0.5012394, 0.5 ],</span>
<span class="sd">           [0. , 0.05762441, ..., 0.4987606, 0.5 ]])</span>
<span class="sd">    &gt;&gt;&gt; r(t)  # doctest: +SKIP</span>
<span class="sd">    array([[-1.00000000e+00, ..., -1.39544265e-10],</span>
<span class="sd">           [ 1.00000000e+00, ...,  1.39544265e-10]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO(schneiderfelipe): raise a meaningful error when y0 has the wrong shape.</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">t_span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># We defined alpha such that 1.0 - alpha is an (under)estimate of the extend</span>
        <span class="c1"># to which the reaction is simulated. And then we apply the Pareto principle.</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.2</span>
        <span class="n">n_halflives</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

        <span class="n">halflife_estimate</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dydt</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">):</span>
            <span class="n">halflife_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span>  <span class="c1"># zeroth-order halflife</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">),</span>  <span class="c1"># first-order halflife</span>
                    <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y0</span><span class="p">)]),</span>  <span class="c1"># second-order halflife</span>
                <span class="p">]</span>
            <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dydt</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;largest halflife guess = </span><span class="si">{</span><span class="n">halflife_estimate</span><span class="si">}</span><span class="s2"> s&quot;</span><span class="p">)</span>

        <span class="n">t_span</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_halflives</span> <span class="o">*</span> <span class="n">halflife_estimate</span><span class="p">,</span> <span class="n">max_time</span><span class="p">)]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;simulation time span   = </span><span class="si">{</span><span class="n">t_span</span><span class="si">}</span><span class="s2"> s&quot;</span><span class="p">)</span>

    <span class="n">jac</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dydt</span><span class="p">,</span> <span class="s2">&quot;jac&quot;</span><span class="p">):</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="n">dydt</span><span class="o">.</span><span class="n">jac</span>

    <span class="c1"># TODO(schneiderfelipe): log solve_ivp stuff.</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span>
        <span class="n">dydt</span><span class="p">,</span>
        <span class="n">t_span</span><span class="p">,</span>
        <span class="n">y0</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="n">dense_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
        <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
        <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">sol</span>

    <span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="c1"># TODO(schneiderfelipe): this is probably not the best way to</span>
        <span class="c1"># vectorize a function!</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dydt</span><span class="p">(</span><span class="n">_t</span><span class="p">,</span> <span class="n">_y</span><span class="p">)</span> <span class="k">for</span> <span class="n">_t</span><span class="p">,</span> <span class="n">_y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dydt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">get_dydt</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ef</span><span class="o">=</span><span class="n">EF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a rate function that models a reaction scheme.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scheme : Scheme</span>
<span class="sd">        A descriptor of the reaction scheme.</span>
<span class="sd">        Mostly likely, this comes from a parsed model input file.</span>
<span class="sd">        See `overreact.io.parse_model`.</span>
<span class="sd">    k : array-like</span>
<span class="sd">        Reaction rate constant(s). Units match the concentration units given to</span>
<span class="sd">        the returned function ``dydt``.</span>
<span class="sd">    ef : float, optional</span>
<span class="sd">        Equilibrium factor. This is a parameter that can be used to scale the</span>
<span class="sd">        reaction rates associated to half-equilibrium reactions such that they</span>
<span class="sd">        are faster than the other reactions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dydt : callable</span>
<span class="sd">        Reaction rate function. The actual reaction rate constants employed</span>
<span class="sd">        are stored in the attribute `k` of the returned function. If JAX is</span>
<span class="sd">        available, the attribute `jac` will hold the Jacobian function of</span>
<span class="sd">        `dydt`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The returned function is suited to be used by ODE solvers such as</span>
<span class="sd">    `scipy.integrate.solve_ivp` or the older `scipy.integrate.ode` (see</span>
<span class="sd">    examples below). This is actually what the function `get_y` from the</span>
<span class="sd">    current module does.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import overreact as rx</span>

<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;A &lt;=&gt; B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; dydt = get_dydt(scheme, np.array([1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; dydt(0.0, np.array([1., 1.]))  # doctest: +SKIP</span>
<span class="sd">    array([0., 0.])</span>

<span class="sd">    If available, JAX is used for JIT compilation. This will make `dydt`</span>
<span class="sd">    complain if given lists instead of numpy arrays. So stick to the safer,</span>
<span class="sd">    faster side as above.</span>

<span class="sd">    The actually used reaction rate constants can be inspected with the `k`</span>
<span class="sd">    attribute of `dydt`:</span>

<span class="sd">    &gt;&gt;&gt; dydt.k  # doctest: +SKIP</span>
<span class="sd">    array([1., 1.])</span>

<span class="sd">    If JAX is available, the Jacobian function will be available as</span>
<span class="sd">    `dydt.jac`:</span>

<span class="sd">    &gt;&gt;&gt; dydt.jac(0.0, np.array([1., 1.]))  # doctest: +SKIP</span>
<span class="sd">    DeviceArray([[-1.,  1.],</span>
<span class="sd">                 [ 1., -1.]], dtype=float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scheme</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">_check_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scheme</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">k_adj</span> <span class="o">=</span> <span class="n">_adjust_k</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ef</span><span class="o">=</span><span class="n">ef</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dydt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">k_adj</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_found_jax</span><span class="p">:</span>
        <span class="c1"># Using JAX for JIT compilation is much faster.</span>
        <span class="n">_dydt</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">_dydt</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_jac</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="c1"># _jac(t, y)[i, j] == d f_i / d y_j</span>
            <span class="c1"># shape is (n_compounds, n_compounds)</span>
            <span class="k">return</span> <span class="n">jacfwd</span><span class="p">(</span><span class="k">lambda</span> <span class="n">_y</span><span class="p">:</span> <span class="n">_dydt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_y</span><span class="p">))(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">_dydt</span><span class="o">.</span><span class="n">jac</span> <span class="o">=</span> <span class="n">_jac</span>

    <span class="n">_dydt</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k_adj</span>
    <span class="k">return</span> <span class="n">_dydt</span>


<span class="k">def</span> <span class="nf">_adjust_k</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ef</span><span class="o">=</span><span class="n">EF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adjust reaction rate constants so that equilibria are equilibria.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scheme : Scheme</span>
<span class="sd">        A descriptor of the reaction scheme.</span>
<span class="sd">        Mostly likely, this comes from a parsed model input file.</span>
<span class="sd">        See `overreact.io.parse_model`.</span>
<span class="sd">    k : array-like</span>
<span class="sd">        Reaction rate constant(s). Units match the concentration units given to</span>
<span class="sd">        the returned function ``dydt``.</span>
<span class="sd">    ef : float, optional</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    k : array-like</span>
<span class="sd">        Adjusted constants.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import overreact as rx</span>

<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;A &lt;=&gt; B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; _adjust_k(scheme, [1, 1])  # doctest: +SKIP</span>
<span class="sd">    array([1., 1.])</span>

<span class="sd">    &gt;&gt;&gt; model = rx.parse_model(&quot;data/ethane/B97-3c/model.k&quot;)</span>
<span class="sd">    &gt;&gt;&gt; _adjust_k(model.scheme,</span>
<span class="sd">    ...           rx.get_k(model.scheme, model.compounds))  # doctest: +SKIP</span>
<span class="sd">    array([8.16880917e+10])</span>

<span class="sd">    &gt;&gt;&gt; model = rx.parse_model(&quot;data/acetate/Orca4/model.k&quot;)</span>
<span class="sd">    &gt;&gt;&gt; _adjust_k(model.scheme,</span>
<span class="sd">    ...           rx.get_k(model.scheme, model.compounds))  # doctest: +SKIP</span>
<span class="sd">    array([1.00000000e+00, 5.74491548e+04, 1.61152010e+07,</span>
<span class="sd">           1.00000000e+00, 1.55695112e+56, 1.00000000e+00])</span>

<span class="sd">    &gt;&gt;&gt; model = rx.parse_model(</span>
<span class="sd">    ...     &quot;data/perez-soto2020/RI/BLYP-D4/def2-TZVP/model.k&quot;</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; _adjust_k(model.scheme,</span>
<span class="sd">    ...           rx.get_k(model.scheme, model.compounds))  # doctest: +SKIP</span>
<span class="sd">    array([1.02320357e+12, ..., 1.02320357e+12])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scheme</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">_check_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">)</span>
    <span class="n">is_half_equilibrium</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scheme</span><span class="o">.</span><span class="n">is_half_equilibrium</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">is_half_equilibrium</span><span class="p">):</span>
        <span class="c1"># at least one equilibrium</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">is_half_equilibrium</span><span class="p">):</span>
            <span class="c1"># at least one true reaction</span>

            <span class="n">k_slowest_equil</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">is_half_equilibrium</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">k_fastest_react</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="o">~</span><span class="n">is_half_equilibrium</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">adjustment</span> <span class="o">=</span> <span class="n">ef</span> <span class="o">*</span> <span class="p">(</span><span class="n">k_fastest_react</span> <span class="o">/</span> <span class="n">k_slowest_equil</span><span class="p">)</span>

            <span class="n">k</span><span class="p">[</span><span class="n">is_half_equilibrium</span><span class="p">]</span> <span class="o">*=</span> <span class="n">adjustment</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;equilibria adjustment = </span><span class="si">{</span><span class="n">adjustment</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">k_slowest_equil</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">is_half_equilibrium</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">k_fastest_react</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="o">~</span><span class="n">is_half_equilibrium</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fast r. / slow eq. = </span><span class="si">{</span><span class="n">k_fastest_react</span><span class="o">/</span><span class="n">k_slowest_equil</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># only equilibria</span>

            <span class="c1"># set the smallest one to be equal to one</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="n">k</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="c1"># else:</span>
    <span class="c1">#     # only zero or more true reactions (no equilibria)</span>
    <span class="c1">#     pass</span>

    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_fixed_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fixed_y0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate an alternative scheme with some concentrations fixed.</span>

<span class="sd">    This function returns data that allow the microkinetic simulation of a</span>
<span class="sd">    reaction network under constraints, namely when some compounds have fixed</span>
<span class="sd">    concentrations. This works by 1. removing all references to the fixed</span>
<span class="sd">    compounds and by 2. properly multiplying the reaction rate constants by</span>
<span class="sd">    the respective concentrations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scheme : Scheme</span>
<span class="sd">        A descriptor of the reaction scheme.</span>
<span class="sd">        Mostly likely, this comes from a parsed model input file.</span>
<span class="sd">        See `overreact.io.parse_model`.</span>
<span class="sd">    k : array-like</span>
<span class="sd">        Reaction rate constant(s). Units match the concentration units given to</span>
<span class="sd">        the returned function ``dydt``.</span>
<span class="sd">    fixed_y0 : dict-like</span>
<span class="sd">        Fixed initial state. Units match the concentration units given to</span>
<span class="sd">        the returned function ``dydt``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scheme : Scheme</span>
<span class="sd">        Associated reaction scheme with all references to fixed compounds</span>
<span class="sd">        removed.</span>
<span class="sd">    k : array-like</span>
<span class="sd">        Associated (effective) reaction rate constants that model the fixed</span>
<span class="sd">        concentrations.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Keep in mind that when a compound get its concentration fixed, the</span>
<span class="sd">    reaction scheme no longer conserves matter. You can think of it as</span>
<span class="sd">    reacting close to an infinite source of the compound, but it accumulates</span>
<span class="sd">    in the milleu at the given concentration.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import overreact as rx</span>

<span class="sd">    Equilibria under a specific pH can be easily modeled:</span>

<span class="sd">    &gt;&gt;&gt; pH = 7</span>
<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;AH &lt;=&gt; A- + H+&quot;)</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([1, 1])</span>
<span class="sd">    &gt;&gt;&gt; scheme, k = rx.get_fixed_scheme(scheme, k, {&quot;H+&quot;: 10**-pH})</span>
<span class="sd">    &gt;&gt;&gt; scheme</span>
<span class="sd">    Scheme(compounds=(&#39;AH&#39;, &#39;A-&#39;),</span>
<span class="sd">           reactions=(&#39;AH -&gt; A-&#39;,</span>
<span class="sd">                      &#39;A- -&gt; AH&#39;),</span>
<span class="sd">           is_half_equilibrium=(True, True),</span>
<span class="sd">           A=((-1.0, 1.0),</span>
<span class="sd">              (1.0, -1.0)),</span>
<span class="sd">           B=((-1.0, 0.0),</span>
<span class="sd">              (1.0, 0.0)))</span>
<span class="sd">    &gt;&gt;&gt; k</span>
<span class="sd">    array([1.e+00, 1.e-07])</span>

<span class="sd">    It is also possible to model the fixed activity of a solvent, for</span>
<span class="sd">    instance:</span>

<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;A + 2H2O -&gt; B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([1.0])</span>
<span class="sd">    &gt;&gt;&gt; scheme, k = rx.get_fixed_scheme(scheme, k, {&quot;H2O&quot;: 55.6})</span>
<span class="sd">    &gt;&gt;&gt; scheme</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.0,),</span>
<span class="sd">              (1.0,)),</span>
<span class="sd">           B=((-1.0,),</span>
<span class="sd">              (1.0,)))</span>
<span class="sd">    &gt;&gt;&gt; k</span>
<span class="sd">    array([3091.36])</span>

<span class="sd">    Multiple reactions work fine, see both examples below:</span>

<span class="sd">    &gt;&gt;&gt; pH = 12</span>
<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;B &lt;- AH &lt;=&gt; A- + H+&quot;)</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([10.0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; scheme, k = rx.get_fixed_scheme(scheme, k, {&quot;H+&quot;: 10**-pH})</span>
<span class="sd">    &gt;&gt;&gt; scheme</span>
<span class="sd">    Scheme(compounds=(&#39;AH&#39;, &#39;B&#39;, &#39;A-&#39;),</span>
<span class="sd">           reactions=(&#39;AH -&gt; B&#39;,</span>
<span class="sd">                      &#39;AH -&gt; A-&#39;,</span>
<span class="sd">                      &#39;A- -&gt; AH&#39;),</span>
<span class="sd">           is_half_equilibrium=(False, True, True),</span>
<span class="sd">           A=((-1.0, -1.0, 1.0),</span>
<span class="sd">              (1.0, 0.0, 0.0),</span>
<span class="sd">              (0.0, 1.0, -1.0)),</span>
<span class="sd">           B=((-1.0, -1.0, 0.0),</span>
<span class="sd">              (1.0, 0.0, 0.0),</span>
<span class="sd">              (0.0, 1.0, 0.0)))</span>
<span class="sd">    &gt;&gt;&gt; k</span>
<span class="sd">    array([1.e+01, 1.e+00, 1.e-12])</span>

<span class="sd">    &gt;&gt;&gt; pH = 2</span>
<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions([&quot;AH &lt;=&gt; A- + H+&quot;, &quot;B- + H+ &lt;=&gt; BH&quot;])</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([1, 1, 2, 2])</span>
<span class="sd">    &gt;&gt;&gt; scheme, k = rx.get_fixed_scheme(scheme, k, {&quot;H+&quot;: 10**-pH})</span>
<span class="sd">    &gt;&gt;&gt; scheme</span>
<span class="sd">    Scheme(compounds=(&#39;AH&#39;, &#39;A-&#39;, &#39;B-&#39;, &#39;BH&#39;),</span>
<span class="sd">           reactions=(&#39;AH -&gt; A-&#39;,</span>
<span class="sd">                      &#39;A- -&gt; AH&#39;,</span>
<span class="sd">                      &#39;B- -&gt; BH&#39;,</span>
<span class="sd">                      &#39;BH -&gt; B-&#39;),</span>
<span class="sd">           is_half_equilibrium=(True, True, True, True),</span>
<span class="sd">           A=((-1.0, 1.0, 0.0, 0.0),</span>
<span class="sd">              (1.0, -1.0, 0.0, 0.0),</span>
<span class="sd">              (0.0, 0.0, -1.0, 1.0),</span>
<span class="sd">              (0.0, 0.0, 1.0, -1.0)),</span>
<span class="sd">           B=((-1.0, 0.0, 0.0, 0.0),</span>
<span class="sd">              (1.0, 0.0, 0.0, 0.0),</span>
<span class="sd">              (0.0, 0.0, -1.0, 0.0),</span>
<span class="sd">              (0.0, 0.0, 1.0, 0.0)))</span>
<span class="sd">    &gt;&gt;&gt; k</span>
<span class="sd">    array([1. , 0.01, 0.02, 2. ])</span>

<span class="sd">    Multiple fixed compounds also work fine:</span>

<span class="sd">    &gt;&gt;&gt; pH = 6</span>
<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;A + H2O -&gt; B &lt;=&gt; B- + H+&quot;)</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([1.0, 100.0, 2.0])</span>
<span class="sd">    &gt;&gt;&gt; scheme, k = rx.get_fixed_scheme(scheme, k, {&quot;H+&quot;: 10**-pH, &quot;H2O&quot;: 55.6})</span>
<span class="sd">    &gt;&gt;&gt; scheme</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;, &#39;B-&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,</span>
<span class="sd">                      &#39;B -&gt; B-&#39;,</span>
<span class="sd">                      &#39;B- -&gt; B&#39;),</span>
<span class="sd">           is_half_equilibrium=(False, True, True),</span>
<span class="sd">           A=((-1.0, 0.0, 0.0),</span>
<span class="sd">              (1.0, -1.0, 1.0),</span>
<span class="sd">              (0.0, 1.0, -1.0)),</span>
<span class="sd">           B=((-1.0, 0.0, 0.0),</span>
<span class="sd">              (1.0, -1.0, 0.0),</span>
<span class="sd">              (0.0, 1.0, 0.0)))</span>
<span class="sd">    &gt;&gt;&gt; k</span>
<span class="sd">    array([5.56e+01, 1.00e+02, 2.00e-06])</span>

<span class="sd">    This function is a no-op if `fixed_y0` is empty, which is very important</span>
<span class="sd">    for overall code consistency:</span>

<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions([&quot;AH &lt;=&gt; A- + H+&quot;, &quot;B- + H+ &lt;=&gt; BH&quot;])</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([1, 1, 2, 2])</span>
<span class="sd">    &gt;&gt;&gt; new_scheme, new_k = rx.get_fixed_scheme(scheme, k, {})</span>
<span class="sd">    &gt;&gt;&gt; new_scheme == scheme</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(new_k, k)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_reactions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">reaction</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">scheme</span><span class="o">.</span><span class="n">reactions</span><span class="p">,</span> <span class="n">scheme</span><span class="o">.</span><span class="n">is_half_equilibrium</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">rx</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">_parse_reactions</span><span class="p">(</span><span class="n">reaction</span><span class="p">):</span>
            <span class="n">new_reactants</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">compound</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">compound</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reactants</span>
                <span class="k">if</span> <span class="n">compound</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_y0</span>
            <span class="p">)</span>
            <span class="n">new_products</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">compound</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">compound</span><span class="p">)</span> <span class="ow">in</span> <span class="n">products</span>
                <span class="k">if</span> <span class="n">compound</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_y0</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">fixed_compound</span> <span class="ow">in</span> <span class="n">fixed_y0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">compound</span> <span class="ow">in</span> <span class="n">reactants</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fixed_compound</span> <span class="o">==</span> <span class="n">compound</span><span class="p">:</span>
                        <span class="n">new_k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">fixed_y0</span><span class="p">[</span><span class="n">fixed_compound</span><span class="p">]</span> <span class="o">**</span> <span class="n">coeff</span>

            <span class="n">new_reactions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_reactants</span><span class="p">,</span> <span class="n">new_products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">))</span>

    <span class="n">new_reactions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rx</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">_unparse_reactions</span><span class="p">(</span><span class="n">new_reactions</span><span class="p">))</span>
    <span class="n">new_is_half_equilibrium</span> <span class="o">=</span> <span class="n">scheme</span><span class="o">.</span><span class="n">is_half_equilibrium</span>

    <span class="n">new_A</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_B</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_compounds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">compound</span><span class="p">,</span> <span class="n">row_A</span><span class="p">,</span> <span class="n">row_B</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">scheme</span><span class="o">.</span><span class="n">compounds</span><span class="p">,</span> <span class="n">scheme</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">scheme</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">compound</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_y0</span><span class="p">:</span>
            <span class="n">new_compounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compound</span><span class="p">)</span>
            <span class="n">new_A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_A</span><span class="p">)</span>
            <span class="n">new_B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_B</span><span class="p">)</span>

    <span class="n">new_compounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_compounds</span><span class="p">)</span>
    <span class="n">new_A</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_A</span><span class="p">)</span>
    <span class="n">new_B</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_B</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">rx</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Scheme</span><span class="p">(</span>
            <span class="n">compounds</span><span class="o">=</span><span class="n">new_compounds</span><span class="p">,</span>
            <span class="n">reactions</span><span class="o">=</span><span class="n">new_reactions</span><span class="p">,</span>
            <span class="n">is_half_equilibrium</span><span class="o">=</span><span class="n">new_is_half_equilibrium</span><span class="p">,</span>
            <span class="n">A</span><span class="o">=</span><span class="n">new_A</span><span class="p">,</span>
            <span class="n">B</span><span class="o">=</span><span class="n">new_B</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">new_k</span><span class="p">,</span>
    <span class="p">)</span>


<span class="c1"># TODO(schneiderfelipe): this is probably not ready yet</span>
<span class="k">def</span> <span class="nf">get_bias</span><span class="p">(</span>
    <span class="n">scheme</span><span class="p">,</span>
    <span class="n">compounds</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">y0</span><span class="p">,</span>
    <span class="n">tunneling</span><span class="o">=</span><span class="s2">&quot;eckart&quot;</span><span class="p">,</span>
    <span class="n">qrrho</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">temperature</span><span class="o">=</span><span class="mf">298.15</span><span class="p">,</span>
    <span class="n">pressure</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">atm</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Radau&quot;</span><span class="p">,</span>
    <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
    <span class="n">atol</span><span class="o">=</span><span class="mf">1e-11</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate a energy bias for a given set of reference data points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scheme : Scheme</span>
<span class="sd">        A descriptor of the reaction scheme.</span>
<span class="sd">        Mostly likely, this comes from a parsed model input file.</span>
<span class="sd">        See `overreact.io.parse_model`.</span>
<span class="sd">    compounds : dict-like</span>
<span class="sd">        A descriptor of the compounds.</span>
<span class="sd">        Mostly likely, this comes from a parsed model input file.</span>
<span class="sd">        See `overreact.io.parse_model`.</span>
<span class="sd">    data : dict-like of array-like</span>
<span class="sd">    y0: array-like</span>
<span class="sd">    tunneling : str or None, optional</span>
<span class="sd">        Choose between &quot;eckart&quot;, &quot;wigner&quot; or None (or &quot;none&quot;).</span>
<span class="sd">    qrrho : bool or tuple-like, optional</span>
<span class="sd">        Apply both the quasi-rigid rotor harmonic oscillator (QRRHO)</span>
<span class="sd">        approximations of M. Head-Gordon and others (enthalpy correction, see</span>
<span class="sd">        [*J. Phys. Chem. C* **2015**, 119, 4, 18401850](http://dx.doi.org/10.1021/jp509921r)) and S. Grimme (entropy correction, see</span>
<span class="sd">        [*Theory. Chem. Eur. J.*, **2012**, 18: 9955-9964](https://doi.org/10.1002/chem.201200497)) on top of the classical RRHO.</span>
<span class="sd">    temperature : array-like, optional</span>
<span class="sd">        Absolute temperature in Kelvin.</span>
<span class="sd">    pressure : array-like, optional</span>
<span class="sd">        Reference gas pressure.</span>
<span class="sd">    delta_freeenergies : array-like, optional</span>
<span class="sd">        Use this instead of obtaining delta free energies from the compounds.</span>
<span class="sd">    molecularity : array-like, optional</span>
<span class="sd">        Reaction order, i.e., number of molecules that come together to react.</span>
<span class="sd">        If set, this is used to calculate `delta_moles` for</span>
<span class="sd">        `equilibrium_constant`, which effectively calculates a solution</span>
<span class="sd">        equilibrium constant between reactants and the transition state for</span>
<span class="sd">        gas phase data. You should set this to `None` if your free energies</span>
<span class="sd">        were already adjusted for solution Gibbs free energies.</span>
<span class="sd">    volume : float, optional</span>
<span class="sd">        Molar volume.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; model = rx.parse_model(&quot;data/tanaka1996/UMP2/cc-pVTZ/model.jk&quot;)</span>

<span class="sd">    The following are some estimates on actual atmospheric concentrations:</span>

<span class="sd">    &gt;&gt;&gt; y0 = [4.8120675684099e-5,</span>
<span class="sd">    ...       2.8206357713029e-5,</span>
<span class="sd">    ...       0.0,</span>
<span class="sd">    ...       0.0,</span>
<span class="sd">    ...       2.7426565371219e-5]</span>
<span class="sd">    &gt;&gt;&gt; data = {&quot;t&quot;: [1.276472128376942246e-6,</span>
<span class="sd">    ...               1.446535794555581743e-4,</span>
<span class="sd">    ...               1.717069678525567564e-2],</span>
<span class="sd">    ...         &quot;CH3&quot;: [9.694916853338366211e-9,</span>
<span class="sd">    ...                  1.066033349343709026e-6,</span>
<span class="sd">    ...                  2.632179124780495175e-5]}</span>
<span class="sd">    &gt;&gt;&gt; get_bias(model.scheme, model.compounds, data, y0) / constants.kcal</span>
<span class="sd">    -1.364171</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;t&quot;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">bias</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">get_k</span><span class="p">(</span>
            <span class="n">scheme</span><span class="p">,</span>
            <span class="n">compounds</span><span class="p">,</span>
            <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span>
            <span class="n">tunneling</span><span class="o">=</span><span class="n">tunneling</span><span class="p">,</span>
            <span class="n">qrrho</span><span class="o">=</span><span class="n">qrrho</span><span class="p">,</span>
            <span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">,</span>
            <span class="n">pressure</span><span class="o">=</span><span class="n">pressure</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># TODO(schneiderfelipe): support schemes with fixed concentrations</span>
        <span class="n">dydt</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">get_dydt</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span>
            <span class="n">dydt</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">max_time</span><span class="o">=</span><span class="n">max_time</span>
        <span class="p">)</span>

        <span class="n">yhat</span> <span class="o">=</span> <span class="n">y</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;t&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="n">yhat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">compounds</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">data</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span>
</pre></div>

        </details>

            </section>
                <section id="get_y">
                            <div class="attr function"><a class="headerlink" href="#get_y">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_y</span><span class="signature">(
    dydt,
    y0,
    t_span=None,
    method=&#39;Radau&#39;,
    rtol=1e-05,
    atol=1e-11,
    max_time=86400
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_y</span><span class="p">(</span>
    <span class="n">dydt</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t_span</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Radau&quot;</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-11</span><span class="p">,</span> <span class="n">max_time</span><span class="o">=</span><span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulate a reaction scheme from its rate function.</span>

<span class="sd">    This function provides two functions that calculate the concentrations and</span>
<span class="sd">    the rates of formation at any point in time for any compound. It does that</span>
<span class="sd">    by solving an initial value problem (IVP) through scipy&#39;s ``solve_ivp``</span>
<span class="sd">    under the hood.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dydt : callable</span>
<span class="sd">        Right-hand side of the system.</span>
<span class="sd">    y0 : array-like</span>
<span class="sd">        Initial state.</span>
<span class="sd">    t_span : array-like, optional</span>
<span class="sd">        Interval of integration (t0, tf). The solver starts with t=t0 and</span>
<span class="sd">        integrates until it reaches t=tf. If not given, a conservative value</span>
<span class="sd">        is chosen based on the system at hand (the method of choice works for</span>
<span class="sd">        any zeroth-, first- or second-order reactions).</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Integration method to use. See `scipy.integrate.solve_ivp` for details.</span>
<span class="sd">        Kinetics problems are very often stiff and, as such, &quot;RK45&quot; is</span>
<span class="sd">        normally unsuited. &quot;Radau&quot;, &quot;BDF&quot; or &quot;LSODA&quot; are good choices.</span>
<span class="sd">    rtol, atol : array-like</span>
<span class="sd">        See `scipy.integrate.solve_ivp` for details.</span>
<span class="sd">    max_time : float, optional</span>
<span class="sd">        If `t_span` is not given, an interval will be estimated, but it can&#39;t</span>
<span class="sd">        be larger than this parameter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y, r : callable</span>
<span class="sd">        Concentrations and reaction rates as functions of time. The y object</span>
<span class="sd">        is an OdeSolution and stores attributes t_min and t_max.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import overreact as rx</span>

<span class="sd">    A toy simulation can be performed in just two lines:</span>

<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;A &lt;=&gt; B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y, r = get_y(get_dydt(scheme, np.array([1, 1])), y0=[1, 0])</span>

<span class="sd">    The `y` object stores information about the simulation time, which can be</span>
<span class="sd">    used to produce a suitable vector of timepoints for, e.g., plotting:</span>

<span class="sd">    &gt;&gt;&gt; y.t_min, y.t_max  # doctest: +SKIP</span>
<span class="sd">    (0.0, 3.0)</span>
<span class="sd">    &gt;&gt;&gt; t = np.linspace(y.t_min, y.t_max)</span>
<span class="sd">    &gt;&gt;&gt; t  # doctest: +SKIP</span>
<span class="sd">    array([0. , 0.06122449, ..., 2.93877551, 3. ])</span>

<span class="sd">    Both `y` and `r` can be used to check concentrations and rates in any</span>
<span class="sd">    point in time. In particular, both are vectorized:</span>

<span class="sd">    &gt;&gt;&gt; y(t)  # doctest: +SKIP</span>
<span class="sd">    array([[1. , 0.94237559, ..., 0.5012394, 0.5 ],</span>
<span class="sd">           [0. , 0.05762441, ..., 0.4987606, 0.5 ]])</span>
<span class="sd">    &gt;&gt;&gt; r(t)  # doctest: +SKIP</span>
<span class="sd">    array([[-1.00000000e+00, ..., -1.39544265e-10],</span>
<span class="sd">           [ 1.00000000e+00, ...,  1.39544265e-10]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO(schneiderfelipe): raise a meaningful error when y0 has the wrong shape.</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">t_span</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># We defined alpha such that 1.0 - alpha is an (under)estimate of the extend</span>
        <span class="c1"># to which the reaction is simulated. And then we apply the Pareto principle.</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.2</span>
        <span class="n">n_halflives</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

        <span class="n">halflife_estimate</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dydt</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">):</span>
            <span class="n">halflife_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span>  <span class="c1"># zeroth-order halflife</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">),</span>  <span class="c1"># first-order halflife</span>
                    <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y0</span><span class="p">)]),</span>  <span class="c1"># second-order halflife</span>
                <span class="p">]</span>
            <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dydt</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;largest halflife guess = </span><span class="si">{</span><span class="n">halflife_estimate</span><span class="si">}</span><span class="s2"> s&quot;</span><span class="p">)</span>

        <span class="n">t_span</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_halflives</span> <span class="o">*</span> <span class="n">halflife_estimate</span><span class="p">,</span> <span class="n">max_time</span><span class="p">)]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;simulation time span   = </span><span class="si">{</span><span class="n">t_span</span><span class="si">}</span><span class="s2"> s&quot;</span><span class="p">)</span>

    <span class="n">jac</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dydt</span><span class="p">,</span> <span class="s2">&quot;jac&quot;</span><span class="p">):</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="n">dydt</span><span class="o">.</span><span class="n">jac</span>

    <span class="c1"># TODO(schneiderfelipe): log solve_ivp stuff.</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span>
        <span class="n">dydt</span><span class="p">,</span>
        <span class="n">t_span</span><span class="p">,</span>
        <span class="n">y0</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="n">dense_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
        <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
        <span class="n">jac</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">sol</span>

    <span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="c1"># TODO(schneiderfelipe): this is probably not the best way to</span>
        <span class="c1"># vectorize a function!</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dydt</span><span class="p">(</span><span class="n">_t</span><span class="p">,</span> <span class="n">_y</span><span class="p">)</span> <span class="k">for</span> <span class="n">_t</span><span class="p">,</span> <span class="n">_y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dydt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span>
</pre></div>

        </details>

            <div class="docstring"><p>Simulate a reaction scheme from its rate function.</p>

<p>This function provides two functions that calculate the concentrations and
the rates of formation at any point in time for any compound. It does that
by solving an initial value problem (IVP) through scipy's <code>solve_ivp</code>
under the hood.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>dydt</strong> (callable):
Right-hand side of the system.</li>
<li><strong>y0</strong> (array-like):
Initial state.</li>
<li><strong>t_span</strong> (array-like, optional):
Interval of integration (t0, tf). The solver starts with t=t0 and
integrates until it reaches t=tf. If not given, a conservative value
is chosen based on the system at hand (the method of choice works for
any zeroth-, first- or second-order reactions).</li>
<li><strong>method</strong> (str, optional):
Integration method to use. See <code>scipy.integrate.solve_ivp</code> for details.
Kinetics problems are very often stiff and, as such, "RK45" is
normally unsuited. "Radau", "BDF" or "LSODA" are good choices.</li>
<li><strong>rtol, atol</strong> (array-like):
See <code>scipy.integrate.solve_ivp</code> for details.</li>
<li><strong>max_time</strong> (float, optional):
If <code>t_span</code> is not given, an interval will be estimated, but it can't
be larger than this parameter.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>y, r</strong> (callable):
Concentrations and reaction rates as functions of time. The y object
is an OdeSolution and stores attributes t_min and t_max.</li>
</ul>

<h6 id="examples">Examples</h6>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">overreact</span> <span class="k">as</span> <span class="nn">rx</span>
</code></pre></div>

<p>A toy simulation can be performed in just two lines:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;A &lt;=&gt; B&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">get_y</span><span class="p">(</span><span class="n">get_dydt</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])),</span> <span class="n">y0</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div>

<p>The <code>y</code> object stores information about the simulation time, which can be
used to produce a suitable vector of timepoints for, e.g., plotting:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">t_min</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">t_max</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">(0.0, 3.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">t_min</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">t_max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">array([0. , 0.06122449, ..., 2.93877551, 3. ])</span>
</code></pre></div>

<p>Both <code>y</code> and <code>r</code> can be used to check concentrations and rates in any
point in time. In particular, both are vectorized:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">array([[1. , 0.94237559, ..., 0.5012394, 0.5 ],</span>
<span class="go">       [0. , 0.05762441, ..., 0.4987606, 0.5 ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">array([[-1.00000000e+00, ..., -1.39544265e-10],</span>
<span class="go">       [ 1.00000000e+00, ...,  1.39544265e-10]])</span>
</code></pre></div>
</div>


                </section>
                <section id="get_dydt">
                            <div class="attr function"><a class="headerlink" href="#get_dydt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_dydt</span><span class="signature">(scheme, k, ef=5)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_dydt</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ef</span><span class="o">=</span><span class="n">EF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a rate function that models a reaction scheme.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scheme : Scheme</span>
<span class="sd">        A descriptor of the reaction scheme.</span>
<span class="sd">        Mostly likely, this comes from a parsed model input file.</span>
<span class="sd">        See `overreact.io.parse_model`.</span>
<span class="sd">    k : array-like</span>
<span class="sd">        Reaction rate constant(s). Units match the concentration units given to</span>
<span class="sd">        the returned function ``dydt``.</span>
<span class="sd">    ef : float, optional</span>
<span class="sd">        Equilibrium factor. This is a parameter that can be used to scale the</span>
<span class="sd">        reaction rates associated to half-equilibrium reactions such that they</span>
<span class="sd">        are faster than the other reactions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dydt : callable</span>
<span class="sd">        Reaction rate function. The actual reaction rate constants employed</span>
<span class="sd">        are stored in the attribute `k` of the returned function. If JAX is</span>
<span class="sd">        available, the attribute `jac` will hold the Jacobian function of</span>
<span class="sd">        `dydt`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The returned function is suited to be used by ODE solvers such as</span>
<span class="sd">    `scipy.integrate.solve_ivp` or the older `scipy.integrate.ode` (see</span>
<span class="sd">    examples below). This is actually what the function `get_y` from the</span>
<span class="sd">    current module does.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import overreact as rx</span>

<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;A &lt;=&gt; B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; dydt = get_dydt(scheme, np.array([1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; dydt(0.0, np.array([1., 1.]))  # doctest: +SKIP</span>
<span class="sd">    array([0., 0.])</span>

<span class="sd">    If available, JAX is used for JIT compilation. This will make `dydt`</span>
<span class="sd">    complain if given lists instead of numpy arrays. So stick to the safer,</span>
<span class="sd">    faster side as above.</span>

<span class="sd">    The actually used reaction rate constants can be inspected with the `k`</span>
<span class="sd">    attribute of `dydt`:</span>

<span class="sd">    &gt;&gt;&gt; dydt.k  # doctest: +SKIP</span>
<span class="sd">    array([1., 1.])</span>

<span class="sd">    If JAX is available, the Jacobian function will be available as</span>
<span class="sd">    `dydt.jac`:</span>

<span class="sd">    &gt;&gt;&gt; dydt.jac(0.0, np.array([1., 1.]))  # doctest: +SKIP</span>
<span class="sd">    DeviceArray([[-1.,  1.],</span>
<span class="sd">                 [ 1., -1.]], dtype=float64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scheme</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">_check_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scheme</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">k_adj</span> <span class="o">=</span> <span class="n">_adjust_k</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ef</span><span class="o">=</span><span class="n">ef</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dydt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">k_adj</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_found_jax</span><span class="p">:</span>
        <span class="c1"># Using JAX for JIT compilation is much faster.</span>
        <span class="n">_dydt</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">_dydt</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_jac</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="c1"># _jac(t, y)[i, j] == d f_i / d y_j</span>
            <span class="c1"># shape is (n_compounds, n_compounds)</span>
            <span class="k">return</span> <span class="n">jacfwd</span><span class="p">(</span><span class="k">lambda</span> <span class="n">_y</span><span class="p">:</span> <span class="n">_dydt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_y</span><span class="p">))(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">_dydt</span><span class="o">.</span><span class="n">jac</span> <span class="o">=</span> <span class="n">_jac</span>

    <span class="n">_dydt</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k_adj</span>
    <span class="k">return</span> <span class="n">_dydt</span>
</pre></div>

        </details>

            <div class="docstring"><p>Generate a rate function that models a reaction scheme.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>scheme</strong> (Scheme):
A descriptor of the reaction scheme.
Mostly likely, this comes from a parsed model input file.
See <code><a href="io.html#parse_model">overreact.io.parse_model</a></code>.</li>
<li><strong>k</strong> (array-like):
Reaction rate constant(s). Units match the concentration units given to
the returned function <code>dydt</code>.</li>
<li><strong>ef</strong> (float, optional):
Equilibrium factor. This is a parameter that can be used to scale the
reaction rates associated to half-equilibrium reactions such that they
are faster than the other reactions.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>dydt</strong> (callable):
Reaction rate function. The actual reaction rate constants employed
are stored in the attribute <code>k</code> of the returned function. If JAX is
available, the attribute <code>jac</code> will hold the Jacobian function of
<code>dydt</code>.</li>
</ul>

<h6 id="notes">Notes</h6>

<p>The returned function is suited to be used by ODE solvers such as
<code>scipy.integrate.solve_ivp</code> or the older <code>scipy.integrate.ode</code> (see
examples below). This is actually what the function <code><a href="#get_y">get_y</a></code> from the
current module does.</p>

<h6 id="examples">Examples</h6>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">overreact</span> <span class="k">as</span> <span class="nn">rx</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;A &lt;=&gt; B&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dydt</span> <span class="o">=</span> <span class="n">get_dydt</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dydt</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]))</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">array([0., 0.])</span>
</code></pre></div>

<p>If available, JAX is used for JIT compilation. This will make <code>dydt</code>
complain if given lists instead of numpy arrays. So stick to the safer,
faster side as above.</p>

<p>The actually used reaction rate constants can be inspected with the <code>k</code>
attribute of <code>dydt</code>:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">dydt</span><span class="o">.</span><span class="n">k</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">array([1., 1.])</span>
</code></pre></div>

<p>If JAX is available, the Jacobian function will be available as
<code>dydt.jac</code>:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">dydt</span><span class="o">.</span><span class="n">jac</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]))</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">DeviceArray([[-1.,  1.],</span>
<span class="go">             [ 1., -1.]], dtype=float64)</span>
</code></pre></div>
</div>


                </section>
                <section id="get_fixed_scheme">
                            <div class="attr function"><a class="headerlink" href="#get_fixed_scheme">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_fixed_scheme</span><span class="signature">(scheme, k, fixed_y0)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_fixed_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">fixed_y0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate an alternative scheme with some concentrations fixed.</span>

<span class="sd">    This function returns data that allow the microkinetic simulation of a</span>
<span class="sd">    reaction network under constraints, namely when some compounds have fixed</span>
<span class="sd">    concentrations. This works by 1. removing all references to the fixed</span>
<span class="sd">    compounds and by 2. properly multiplying the reaction rate constants by</span>
<span class="sd">    the respective concentrations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scheme : Scheme</span>
<span class="sd">        A descriptor of the reaction scheme.</span>
<span class="sd">        Mostly likely, this comes from a parsed model input file.</span>
<span class="sd">        See `overreact.io.parse_model`.</span>
<span class="sd">    k : array-like</span>
<span class="sd">        Reaction rate constant(s). Units match the concentration units given to</span>
<span class="sd">        the returned function ``dydt``.</span>
<span class="sd">    fixed_y0 : dict-like</span>
<span class="sd">        Fixed initial state. Units match the concentration units given to</span>
<span class="sd">        the returned function ``dydt``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scheme : Scheme</span>
<span class="sd">        Associated reaction scheme with all references to fixed compounds</span>
<span class="sd">        removed.</span>
<span class="sd">    k : array-like</span>
<span class="sd">        Associated (effective) reaction rate constants that model the fixed</span>
<span class="sd">        concentrations.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Keep in mind that when a compound get its concentration fixed, the</span>
<span class="sd">    reaction scheme no longer conserves matter. You can think of it as</span>
<span class="sd">    reacting close to an infinite source of the compound, but it accumulates</span>
<span class="sd">    in the milleu at the given concentration.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import overreact as rx</span>

<span class="sd">    Equilibria under a specific pH can be easily modeled:</span>

<span class="sd">    &gt;&gt;&gt; pH = 7</span>
<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;AH &lt;=&gt; A- + H+&quot;)</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([1, 1])</span>
<span class="sd">    &gt;&gt;&gt; scheme, k = rx.get_fixed_scheme(scheme, k, {&quot;H+&quot;: 10**-pH})</span>
<span class="sd">    &gt;&gt;&gt; scheme</span>
<span class="sd">    Scheme(compounds=(&#39;AH&#39;, &#39;A-&#39;),</span>
<span class="sd">           reactions=(&#39;AH -&gt; A-&#39;,</span>
<span class="sd">                      &#39;A- -&gt; AH&#39;),</span>
<span class="sd">           is_half_equilibrium=(True, True),</span>
<span class="sd">           A=((-1.0, 1.0),</span>
<span class="sd">              (1.0, -1.0)),</span>
<span class="sd">           B=((-1.0, 0.0),</span>
<span class="sd">              (1.0, 0.0)))</span>
<span class="sd">    &gt;&gt;&gt; k</span>
<span class="sd">    array([1.e+00, 1.e-07])</span>

<span class="sd">    It is also possible to model the fixed activity of a solvent, for</span>
<span class="sd">    instance:</span>

<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;A + 2H2O -&gt; B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([1.0])</span>
<span class="sd">    &gt;&gt;&gt; scheme, k = rx.get_fixed_scheme(scheme, k, {&quot;H2O&quot;: 55.6})</span>
<span class="sd">    &gt;&gt;&gt; scheme</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="sd">           is_half_equilibrium=(False,),</span>
<span class="sd">           A=((-1.0,),</span>
<span class="sd">              (1.0,)),</span>
<span class="sd">           B=((-1.0,),</span>
<span class="sd">              (1.0,)))</span>
<span class="sd">    &gt;&gt;&gt; k</span>
<span class="sd">    array([3091.36])</span>

<span class="sd">    Multiple reactions work fine, see both examples below:</span>

<span class="sd">    &gt;&gt;&gt; pH = 12</span>
<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;B &lt;- AH &lt;=&gt; A- + H+&quot;)</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([10.0, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; scheme, k = rx.get_fixed_scheme(scheme, k, {&quot;H+&quot;: 10**-pH})</span>
<span class="sd">    &gt;&gt;&gt; scheme</span>
<span class="sd">    Scheme(compounds=(&#39;AH&#39;, &#39;B&#39;, &#39;A-&#39;),</span>
<span class="sd">           reactions=(&#39;AH -&gt; B&#39;,</span>
<span class="sd">                      &#39;AH -&gt; A-&#39;,</span>
<span class="sd">                      &#39;A- -&gt; AH&#39;),</span>
<span class="sd">           is_half_equilibrium=(False, True, True),</span>
<span class="sd">           A=((-1.0, -1.0, 1.0),</span>
<span class="sd">              (1.0, 0.0, 0.0),</span>
<span class="sd">              (0.0, 1.0, -1.0)),</span>
<span class="sd">           B=((-1.0, -1.0, 0.0),</span>
<span class="sd">              (1.0, 0.0, 0.0),</span>
<span class="sd">              (0.0, 1.0, 0.0)))</span>
<span class="sd">    &gt;&gt;&gt; k</span>
<span class="sd">    array([1.e+01, 1.e+00, 1.e-12])</span>

<span class="sd">    &gt;&gt;&gt; pH = 2</span>
<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions([&quot;AH &lt;=&gt; A- + H+&quot;, &quot;B- + H+ &lt;=&gt; BH&quot;])</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([1, 1, 2, 2])</span>
<span class="sd">    &gt;&gt;&gt; scheme, k = rx.get_fixed_scheme(scheme, k, {&quot;H+&quot;: 10**-pH})</span>
<span class="sd">    &gt;&gt;&gt; scheme</span>
<span class="sd">    Scheme(compounds=(&#39;AH&#39;, &#39;A-&#39;, &#39;B-&#39;, &#39;BH&#39;),</span>
<span class="sd">           reactions=(&#39;AH -&gt; A-&#39;,</span>
<span class="sd">                      &#39;A- -&gt; AH&#39;,</span>
<span class="sd">                      &#39;B- -&gt; BH&#39;,</span>
<span class="sd">                      &#39;BH -&gt; B-&#39;),</span>
<span class="sd">           is_half_equilibrium=(True, True, True, True),</span>
<span class="sd">           A=((-1.0, 1.0, 0.0, 0.0),</span>
<span class="sd">              (1.0, -1.0, 0.0, 0.0),</span>
<span class="sd">              (0.0, 0.0, -1.0, 1.0),</span>
<span class="sd">              (0.0, 0.0, 1.0, -1.0)),</span>
<span class="sd">           B=((-1.0, 0.0, 0.0, 0.0),</span>
<span class="sd">              (1.0, 0.0, 0.0, 0.0),</span>
<span class="sd">              (0.0, 0.0, -1.0, 0.0),</span>
<span class="sd">              (0.0, 0.0, 1.0, 0.0)))</span>
<span class="sd">    &gt;&gt;&gt; k</span>
<span class="sd">    array([1. , 0.01, 0.02, 2. ])</span>

<span class="sd">    Multiple fixed compounds also work fine:</span>

<span class="sd">    &gt;&gt;&gt; pH = 6</span>
<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions(&quot;A + H2O -&gt; B &lt;=&gt; B- + H+&quot;)</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([1.0, 100.0, 2.0])</span>
<span class="sd">    &gt;&gt;&gt; scheme, k = rx.get_fixed_scheme(scheme, k, {&quot;H+&quot;: 10**-pH, &quot;H2O&quot;: 55.6})</span>
<span class="sd">    &gt;&gt;&gt; scheme</span>
<span class="sd">    Scheme(compounds=(&#39;A&#39;, &#39;B&#39;, &#39;B-&#39;),</span>
<span class="sd">           reactions=(&#39;A -&gt; B&#39;,</span>
<span class="sd">                      &#39;B -&gt; B-&#39;,</span>
<span class="sd">                      &#39;B- -&gt; B&#39;),</span>
<span class="sd">           is_half_equilibrium=(False, True, True),</span>
<span class="sd">           A=((-1.0, 0.0, 0.0),</span>
<span class="sd">              (1.0, -1.0, 1.0),</span>
<span class="sd">              (0.0, 1.0, -1.0)),</span>
<span class="sd">           B=((-1.0, 0.0, 0.0),</span>
<span class="sd">              (1.0, -1.0, 0.0),</span>
<span class="sd">              (0.0, 1.0, 0.0)))</span>
<span class="sd">    &gt;&gt;&gt; k</span>
<span class="sd">    array([5.56e+01, 1.00e+02, 2.00e-06])</span>

<span class="sd">    This function is a no-op if `fixed_y0` is empty, which is very important</span>
<span class="sd">    for overall code consistency:</span>

<span class="sd">    &gt;&gt;&gt; scheme = rx.parse_reactions([&quot;AH &lt;=&gt; A- + H+&quot;, &quot;B- + H+ &lt;=&gt; BH&quot;])</span>
<span class="sd">    &gt;&gt;&gt; k = np.array([1, 1, 2, 2])</span>
<span class="sd">    &gt;&gt;&gt; new_scheme, new_k = rx.get_fixed_scheme(scheme, k, {})</span>
<span class="sd">    &gt;&gt;&gt; new_scheme == scheme</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(new_k, k)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_reactions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">reaction</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">scheme</span><span class="o">.</span><span class="n">reactions</span><span class="p">,</span> <span class="n">scheme</span><span class="o">.</span><span class="n">is_half_equilibrium</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">reactants</span><span class="p">,</span> <span class="n">products</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">rx</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">_parse_reactions</span><span class="p">(</span><span class="n">reaction</span><span class="p">):</span>
            <span class="n">new_reactants</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">compound</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">compound</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reactants</span>
                <span class="k">if</span> <span class="n">compound</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_y0</span>
            <span class="p">)</span>
            <span class="n">new_products</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">compound</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">compound</span><span class="p">)</span> <span class="ow">in</span> <span class="n">products</span>
                <span class="k">if</span> <span class="n">compound</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_y0</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">fixed_compound</span> <span class="ow">in</span> <span class="n">fixed_y0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">compound</span> <span class="ow">in</span> <span class="n">reactants</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fixed_compound</span> <span class="o">==</span> <span class="n">compound</span><span class="p">:</span>
                        <span class="n">new_k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">fixed_y0</span><span class="p">[</span><span class="n">fixed_compound</span><span class="p">]</span> <span class="o">**</span> <span class="n">coeff</span>

            <span class="n">new_reactions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_reactants</span><span class="p">,</span> <span class="n">new_products</span><span class="p">,</span> <span class="n">is_half_equilibrium</span><span class="p">))</span>

    <span class="n">new_reactions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rx</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">_unparse_reactions</span><span class="p">(</span><span class="n">new_reactions</span><span class="p">))</span>
    <span class="n">new_is_half_equilibrium</span> <span class="o">=</span> <span class="n">scheme</span><span class="o">.</span><span class="n">is_half_equilibrium</span>

    <span class="n">new_A</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_B</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_compounds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">compound</span><span class="p">,</span> <span class="n">row_A</span><span class="p">,</span> <span class="n">row_B</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">scheme</span><span class="o">.</span><span class="n">compounds</span><span class="p">,</span> <span class="n">scheme</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">scheme</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">compound</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_y0</span><span class="p">:</span>
            <span class="n">new_compounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compound</span><span class="p">)</span>
            <span class="n">new_A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_A</span><span class="p">)</span>
            <span class="n">new_B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_B</span><span class="p">)</span>

    <span class="n">new_compounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_compounds</span><span class="p">)</span>
    <span class="n">new_A</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_A</span><span class="p">)</span>
    <span class="n">new_B</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_B</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">rx</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Scheme</span><span class="p">(</span>
            <span class="n">compounds</span><span class="o">=</span><span class="n">new_compounds</span><span class="p">,</span>
            <span class="n">reactions</span><span class="o">=</span><span class="n">new_reactions</span><span class="p">,</span>
            <span class="n">is_half_equilibrium</span><span class="o">=</span><span class="n">new_is_half_equilibrium</span><span class="p">,</span>
            <span class="n">A</span><span class="o">=</span><span class="n">new_A</span><span class="p">,</span>
            <span class="n">B</span><span class="o">=</span><span class="n">new_B</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">new_k</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Generate an alternative scheme with some concentrations fixed.</p>

<p>This function returns data that allow the microkinetic simulation of a
reaction network under constraints, namely when some compounds have fixed
concentrations. This works by 1. removing all references to the fixed
compounds and by 2. properly multiplying the reaction rate constants by
the respective concentrations.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>scheme</strong> (Scheme):
A descriptor of the reaction scheme.
Mostly likely, this comes from a parsed model input file.
See <code><a href="io.html#parse_model">overreact.io.parse_model</a></code>.</li>
<li><strong>k</strong> (array-like):
Reaction rate constant(s). Units match the concentration units given to
the returned function <code>dydt</code>.</li>
<li><strong>fixed_y0</strong> (dict-like):
Fixed initial state. Units match the concentration units given to
the returned function <code>dydt</code>.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>scheme</strong> (Scheme):
Associated reaction scheme with all references to fixed compounds
removed.</li>
<li><strong>k</strong> (array-like):
Associated (effective) reaction rate constants that model the fixed
concentrations.</li>
</ul>

<h6 id="notes">Notes</h6>

<p>Keep in mind that when a compound get its concentration fixed, the
reaction scheme no longer conserves matter. You can think of it as
reacting close to an infinite source of the compound, but it accumulates
in the milleu at the given concentration.</p>

<h6 id="examples">Examples</h6>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">overreact</span> <span class="k">as</span> <span class="nn">rx</span>
</code></pre></div>

<p>Equilibria under a specific pH can be easily modeled:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pH</span> <span class="o">=</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;AH &lt;=&gt; A- + H+&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">get_fixed_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;H+&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**-</span><span class="n">pH</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span>
<span class="go">Scheme(compounds=(&#39;AH&#39;, &#39;A-&#39;),</span>
<span class="go">       reactions=(&#39;AH -&gt; A-&#39;,</span>
<span class="go">                  &#39;A- -&gt; AH&#39;),</span>
<span class="go">       is_half_equilibrium=(True, True),</span>
<span class="go">       A=((-1.0, 1.0),</span>
<span class="go">          (1.0, -1.0)),</span>
<span class="go">       B=((-1.0, 0.0),</span>
<span class="go">          (1.0, 0.0)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span>
<span class="go">array([1.e+00, 1.e-07])</span>
</code></pre></div>

<p>It is also possible to model the fixed activity of a solvent, for
instance:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;A + 2H2O -&gt; B&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">get_fixed_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;H2O&quot;</span><span class="p">:</span> <span class="mf">55.6</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span>
<span class="go">Scheme(compounds=(&#39;A&#39;, &#39;B&#39;),</span>
<span class="go">       reactions=(&#39;A -&gt; B&#39;,),</span>
<span class="go">       is_half_equilibrium=(False,),</span>
<span class="go">       A=((-1.0,),</span>
<span class="go">          (1.0,)),</span>
<span class="go">       B=((-1.0,),</span>
<span class="go">          (1.0,)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span>
<span class="go">array([3091.36])</span>
</code></pre></div>

<p>Multiple reactions work fine, see both examples below:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pH</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;B &lt;- AH &lt;=&gt; A- + H+&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">10.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">get_fixed_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;H+&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**-</span><span class="n">pH</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span>
<span class="go">Scheme(compounds=(&#39;AH&#39;, &#39;B&#39;, &#39;A-&#39;),</span>
<span class="go">       reactions=(&#39;AH -&gt; B&#39;,</span>
<span class="go">                  &#39;AH -&gt; A-&#39;,</span>
<span class="go">                  &#39;A- -&gt; AH&#39;),</span>
<span class="go">       is_half_equilibrium=(False, True, True),</span>
<span class="go">       A=((-1.0, -1.0, 1.0),</span>
<span class="go">          (1.0, 0.0, 0.0),</span>
<span class="go">          (0.0, 1.0, -1.0)),</span>
<span class="go">       B=((-1.0, -1.0, 0.0),</span>
<span class="go">          (1.0, 0.0, 0.0),</span>
<span class="go">          (0.0, 1.0, 0.0)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span>
<span class="go">array([1.e+01, 1.e+00, 1.e-12])</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pH</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">parse_reactions</span><span class="p">([</span><span class="s2">&quot;AH &lt;=&gt; A- + H+&quot;</span><span class="p">,</span> <span class="s2">&quot;B- + H+ &lt;=&gt; BH&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">get_fixed_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;H+&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**-</span><span class="n">pH</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span>
<span class="go">Scheme(compounds=(&#39;AH&#39;, &#39;A-&#39;, &#39;B-&#39;, &#39;BH&#39;),</span>
<span class="go">       reactions=(&#39;AH -&gt; A-&#39;,</span>
<span class="go">                  &#39;A- -&gt; AH&#39;,</span>
<span class="go">                  &#39;B- -&gt; BH&#39;,</span>
<span class="go">                  &#39;BH -&gt; B-&#39;),</span>
<span class="go">       is_half_equilibrium=(True, True, True, True),</span>
<span class="go">       A=((-1.0, 1.0, 0.0, 0.0),</span>
<span class="go">          (1.0, -1.0, 0.0, 0.0),</span>
<span class="go">          (0.0, 0.0, -1.0, 1.0),</span>
<span class="go">          (0.0, 0.0, 1.0, -1.0)),</span>
<span class="go">       B=((-1.0, 0.0, 0.0, 0.0),</span>
<span class="go">          (1.0, 0.0, 0.0, 0.0),</span>
<span class="go">          (0.0, 0.0, -1.0, 0.0),</span>
<span class="go">          (0.0, 0.0, 1.0, 0.0)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span>
<span class="go">array([1. , 0.01, 0.02, 2. ])</span>
</code></pre></div>

<p>Multiple fixed compounds also work fine:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pH</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">parse_reactions</span><span class="p">(</span><span class="s2">&quot;A + H2O -&gt; B &lt;=&gt; B- + H+&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">get_fixed_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;H+&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**-</span><span class="n">pH</span><span class="p">,</span> <span class="s2">&quot;H2O&quot;</span><span class="p">:</span> <span class="mf">55.6</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span>
<span class="go">Scheme(compounds=(&#39;A&#39;, &#39;B&#39;, &#39;B-&#39;),</span>
<span class="go">       reactions=(&#39;A -&gt; B&#39;,</span>
<span class="go">                  &#39;B -&gt; B-&#39;,</span>
<span class="go">                  &#39;B- -&gt; B&#39;),</span>
<span class="go">       is_half_equilibrium=(False, True, True),</span>
<span class="go">       A=((-1.0, 0.0, 0.0),</span>
<span class="go">          (1.0, -1.0, 1.0),</span>
<span class="go">          (0.0, 1.0, -1.0)),</span>
<span class="go">       B=((-1.0, 0.0, 0.0),</span>
<span class="go">          (1.0, -1.0, 0.0),</span>
<span class="go">          (0.0, 1.0, 0.0)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span>
<span class="go">array([5.56e+01, 1.00e+02, 2.00e-06])</span>
</code></pre></div>

<p>This function is a no-op if <code>fixed_y0</code> is empty, which is very important
for overall code consistency:</p>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">parse_reactions</span><span class="p">([</span><span class="s2">&quot;AH &lt;=&gt; A- + H+&quot;</span><span class="p">,</span> <span class="s2">&quot;B- + H+ &lt;=&gt; BH&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_scheme</span><span class="p">,</span> <span class="n">new_k</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">get_fixed_scheme</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">{})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_scheme</span> <span class="o">==</span> <span class="n">scheme</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">new_k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
<span class="go">True</span>
</code></pre></div>
</div>


                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>